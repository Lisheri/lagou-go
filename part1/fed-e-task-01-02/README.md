# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```

10

首先js是词法作用域, 函数定义时就已经决定了他寻找的自由变量所在的作用域是哪一个, 这里的i使用var定义, 因此相当于处在全局作用域下, 因此这里所有的函数最终只有一个`[[Scopes]]`, 就是global, 而global下的i在循环执行完之后是10。当然, `a[i]`中的i不是10, 因为他在循环体内部直接执行了, 在将函数赋值给`a[i]`时, i的值就是当前循环走到那个位置的i

　

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

报错　ReferenceError, 不能在初始化之前获取tmp

由于if语句下使用`{}`, 形成了一个块级作用域, 而块级作用域内部使用let定义tmp时, 会有一个类似提升的行为, 为什么说类似提升呢, 因为他和var的提升不同，块级作用域的初始化, 仅仅只是先查找let, 然后创建let定义的变量, 但是没有初始化, var不同, var不仅创建变量, 还会初始化为undefined, 紧接着开始执行块内语句, 走到定义出才会初始化值, 因此, 在块内顶部到定义的中间区域, 就形成了一个暂时性死区, 在这之间都不允许使用let/const定义的变量。(当然, 我感觉可能是因为两个提升是不一样的, MDN才没有算let有提升吧, 并且MDN是有修改痕迹的。)倘若let定义不是进入块就存在一个类似提升的效果, 那么这里就应该拿到global下的tmp, 也就是123了。

　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

最小值: 

+ 方法一: ```Math.min(...[arr])```
+ 方法二: ```arr.sort((a, b) => a - b)[0]```
      

　

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别

+ var: var定义的变量只有函数作用域和全局作用域, 并且在同一个作用域内部存在提升, 也就是进入作用域首先会将所有var定义的变量创建并初始化为undefined, 到定义处直接赋值, 因此在定义处之前也可以使用和赋值。
+ let/const: 定义的变量不仅有var的函数作用域和全局作用域, 还存在块级作用域, 并且进入作用域内部也有一个类似提升的行为, 但是和var不同的是他只创建不初始化, 到定义处才会初始化并赋值, 因此在块内顶部到定义处就存在一个暂时性死区, 调用let/const定义的变量就报错，错误信息是无法在初始化前获取变量。
+ let: 目前版本下let允许重复定义, 并且let定义的值可以被修改
+ const: const不允许重复定义, 同时const定义的值在栈内不允许被修改(引用类型可以修改存储在堆内的值)

　

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

20

fn定义在obj内部, 同时执行fn的是obj, fn是一个普通函数, 普通函数的this指向是动态的调用时决定, 指向调用者, fn的调用者是obj, 虽然是setTimeout调用内部函数, setTimeout指向的是global, 但是setTimeout内部定义的是箭头函数, 箭头函数没有自己的this, 继承自父级作用域, 他的父级是fn, 因此指向fn的this, fn的this指向obj, 因此this.a就是obj.a, 也就是20

　

### 6. 简述Symbol类型的用途

+ 由于Symbol在全局只能有一个, 因此他可以用于解决属性名重复的问题。同时, 对象的键名可以使用Symbol, 因此它目前最主要的问题就是解决对象属性名重复的问题
+ 同时Symbol是独一无二的成员, 外界新创建的Symbol和内部的引用不是同一个, 因此无法在外界直接访问对象内部的Symbol键, 所以它还可以用于定义内部私有成员
+ 同时Symbol.for(string)还可以用于维护一个全局的注册表, 重复注册会直接返回原来的那个, 而不是替换他(类似对象直接复制)。可以使用Symbol.keyFor(变量名)查找for注册的那个字符串
+ js大量的内置操作都是Symbol定义的, 比如```obj[Symbol.toPrimitive]() {}```可用于覆盖原先的对象转原始类型的方法

　

### 7. 说说什么是浅拷贝，什么是深拷贝？

+ 复制: 首先要说一下引用类型直接复制, 就是直接在栈内开辟一个新的空间, 复制了原对象存储在栈内的指针, 因此新的对象和原对象在栈内的指针都指向同一个堆地址。因此改变新对象内部的值, 原对象也跟着变化了, 因为他们改写的都是同一个堆
+ 浅拷贝: 浅拷贝之所以叫浅拷贝是因为他让一个对象的第一层解脱了直接复制, b对象浅拷贝a对象的时候, 会在堆中开辟一个新的空间, 用于存储a对象的第一层数据, 然后b的指针指向了这个新的堆地址, 但是第一层内部如果还有对象, 这个对象的键名, 还是指向原来a对象第一层下该对象的键所指向的地址。常见浅拷贝的方式有: Object.assign, concat, Array.prototype.slice，扩展运算符和解构赋值(解构出来只有一层就是一个浅拷贝)
+ 深拷贝: 完全复制原对象的值, 在堆中层层开辟新的空间, 仅用于存储原对象的值, 将新的键存储在栈中的指针指向新的空间。因此深拷贝后的对象完全脱离原对象, 改变新的对象任何层级都不会影响原来的对象。

　

### 8. 请简述TypeScript与JavaScript之间的关系？

TypeScript是JavaScript的超集, TS多了更强大的类型系统和ES6+的新特性, 最终会被编译为JS, 可以配置编译的JS版本, 同时任何一个js环境都可以运行ts。

类型检查可以帮助我们在开发阶段避开更多由于类型转换带来的bug。

　

### 9. 请谈谈你所认为的typescript优缺点

> 优点: 
> 代码可读性和可维护性高, 从开发前期就限制了变量的类型, 易于后期人员的维护, 并且避开了由于类型转换带来的bug
> TS包容性好, 使用TS时, 不需要完全掌握TS的语法, 只要正常使用JS就行, 哪怕有类型系统的报错, 只要你心里清除他真的没有问题, 也可以编译为js并运行
> TS拥有活跃的社区, 大部分的第三方库都提供了TS的类型声明文件
> 同时TS还拥抱最新的ES规范, 配置中有一个ESNext的选项, 哪怕是最新的ES2020也很快就可以使用了(类似?.这种操作符)

> 缺点:
> 有一定的学习成本, 如果没有接触过较强类型的语言如C, C++ 这一类(虽然他还是弱类型, 但是比js的类型系统更强)语言, 对interface、泛型、类、枚举等非传统js范畴的概念理解起来有一定的难度。
> 前期开发成本较高，因为要定义较多的interface用于限制对象、函数参数和函数返回值等的类型
> 集成到构建也需要额外的成本
> 有一些第三方库没有自己支持TS的类型声明, 引入会有报错

　

### 10. 描述引用计数的工作原理和优缺点

依赖一个引用计数器来计算某引用类型的被引用数, 判断当前引用数是否为0来决定是不是一个垃圾对象, 当他变为垃圾对象后gc就会立即开始回收并清理堆内存

> 优点:
> 发现垃圾就立即回收
> 最大限度的减少程序暂停: 应用程序在执行过程中不可避免的要消耗内存, 但是引用计数算法依赖一个实时监控的引用计数器, 当引用数归零后立即启动gc开始回收, 降低堆内存沾满的风险, 也就减少了程序的暂停。

> 缺点:
> 无法回收循环引用对象: 引用计数器会发现他们一直都存在1个引用, 不会归零
> 时间开销大: 本身实时监控引用对象的引用数值变化时做出修改就是一个耗时间的过程, 当大量的引用对象快速先后改变引用数时, 引用计数器将做出大量的引用数修改, 这样一来时间占用就更高了

　

### 11. 描述标记整理算法的工作流程

首先分成标记阶段和清除整理阶段

+ 标记阶段: 从根节点开始遍历所有对象, 并且对所有可达对象添加标记
+ 清除整理阶段: 将所有的存活对象压缩到内存的一段，之后清理剩下的没有带标记的对象, 并且清除之前的标记

　

### 12.描述V8中新生代存储区垃圾回收的流程

+ 首先新生代中用于存储存活时间较短的对象, 新生代空间将一分为二拆成两个部分(平分空间), from表示正在使用的内存, to表示闲置内存
+ 回收过程中采用复制算法+标记整理算法
+ 进行垃圾回收的时候, v8先遍历from空间, 进行标记整理, 如果是存活对象(带标记的)直接移动到to中, 移动的时候有一个整理的操作, 就是他是从头到尾顺序存放的, 不会出现碎片(这个算法叫做Scavenge), 然后还留在from中的对象就是垃圾, 直接回收
+ 当所有存活对象都进入to之后, 他们的身份就会对调, 原来的to表示存活空间, 原来的from表示闲置空间, 然后继续上述操作
+ 当闲置空间占用超过25%, 会发生晋升, 或者说已经经历过一次新生代回收后他还在to中, 也要晋升

　

### 13. 描述增量标记算法在何时使用及工作原理

增量标记算法在v8回收老生代堆内存时标记阶段使用, v8回收老生代分为标记-清除阶段和整理碎片阶段, 标记-清除阶段又分为标记阶段和清除阶段，标记阶段会遍历堆中所有对象并打上标记, 然后对代码中正在使用的对象和强引用取消标记, 剩下的就是垃圾对象了，清除阶段就对带有标记的进行回收, 这里就有了内存碎片, 因此要进行碎片整理, 老生代碎片整理简单粗暴, 直接把从一端向另一端移动。

上述标记阶段就要使用增量标记算法, 由于JS是单线程，因此在进行垃圾回收的时候不可避免的要阻塞业务逻辑的执行, 倘若老生代回收任务很重, 那么耗时将会极其可怕,严重影响性能, 于是V8做了一步大胆的优化, 就是对一口气完成的标记任务进行增量标记, 将他们拆成一块一块的, 标记一块就执行一会儿js主线程下的逻辑, 直到标记完成才进入清除和碎片整理。



　